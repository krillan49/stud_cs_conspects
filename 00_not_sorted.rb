# программа - набор инструкций для компьютера, обычно в виде текста написанном в фаиле. Компилятор или интерпритатор преобразовывает текст программы в набор команд для компьютера, которые тот потом выполняет. Та программа, что мы скачиваем, например Руби - это и есть интерпритатор, тоесть сам Руби может интерпритировать код Руби, библиотека добавляет инструкций по интерпритации кода написанного с помощью функционала этой библиотеки.
# Расширение фаила помогает понять интерпритаторам или компиляторам, что это их фаил, а IDE показывает как именно в нем подсвечивать текст

# терминал / командная строка / консоль - интерфейс операционной системы, но не графический, а текстовый. Принимает команду (1е слово и ее параметры через пробел). Терминал всегда находится в какой-то директьории, которая называется текущая
# Когда вводим команду в терминале и имя какого-то фаила или директории достаточно ввести его уникальную часть и нажать "tab"

# 1 Бит - это выбор из 2х вариантов(вкл и выкл) - Ячейка памяти компьютера состоят из таких переключателей.
# 8 Бит = 1Байт(выбор из 256(2**8) вариантов)


# https://lumpics.ru/environment-variables-in-windows-10/    про переменную  PATH

# Зачем добавлять в путь:
# добавить в переменную PATH каталог, в котором размещен исполняемый файл программы. Это избавит от необходимости каждый раз открывать файловый менеджер и переходить в папку с программой.


# Как читать код оказавшись в новом проекте, от самого лучшего способа к менее лучшим:
# 1. Коммиты, начиная с первого, если они норм а не простыни с горой кода в перемешку
# 2. Доки если есть
# 3. Тесты если есть
# 4. Посмотреть приложение через пользовательский интерфейс, потыкав всякое


# У браузера своя по сути виртуальная машина, в которой исполняется особый сорт программ. Грубо говоря это HTML (композиция элементов страницы) + CSS (отрисовка элементов страницы) + JS (манипулирование элементами, динамический отклик и т.д. и т.п.).
# С другой стороны, бекенд это просто ну вот программа на компьютере, исполняемый файл (для интерпретируемых языков - файл с кодом + программа-интерпретатор).


# насчет путаницы в терминологии.
# Hash table - это структура данных основанная на массиве и вычислении хеш функций от хранимых данных.
# Map - это древесная структура данных, основанная на упорядочивании элементов между собой и хранении их в дереве.
# Обе эти структуры могут быть названы Map, потому что обе они осуществляют mapping(отображение) из одного множества в другое. Обе этих структуры принимают ключ(это первое множество) и возвращают значение(это второе множество). Отсюда путаница между общефилосовским Map и древесным map


# Микросервисы - это разные приложения, которые могут общаться друг с другом передавая что-то в другие микросервисы, например через HTTP или просто на одной машине ??


# Любая операционная система это набор фаилв



puts '                        Как программа использует оперативную память и процессор'

# Оперативную память распределяет операционная система. Каждой программе она выделяет часть оперативной памяти, обычно выделяет столько памяти сколько нужно программе, пока есть свободная память. Но если память кончается, то ОС начинает использовать "Своп", тоесть в качестве дополнительной пмяти начинает использовать жесткий диск, записывая на него данные, которые иначе хранились бы в оперативной памяти, но это приводит к сильному замедлению работы системы и приложения, тк хард диски работаю намного меденне чем оперативная память

# Главное чем занимает оперативную память программа - это объекты которые она создает. Каждый раз когда создается число, строка, объект какого-то класса, открывается какой-то фаил - то программа занимает еще места в оперативной памяти под этот объект. Простые объекты (строки, чисчла) занимают мало места в памяти, но чем сложнее класс, чем больше у него полей тем больше места в оперативной памяти занимают объекты этого класса


# Проверить сколько объекты занимают памяти
arr = []
1000.times { |i| arr << "some #{i}" }
gets
# Теперь когда програма ожижает ввод можно посмотреть (например в диспетчере задач|подробности процесс ruby.exe), тут это будет 10452 Кб
# Теперь увеличим число объектов с 1000 до миллиона и снова зпустим и получим 93388 Кб


# Жизненный цикл объекта (похож во многих языках):
# 1. Объект создается в памяти и на него указывают какие-то ссылки
a = MyClass.new # создаем объект класса "MyClass", на который указывает переменная "a"
b = a # создадим еще одну переменную, указывающую на тот же объект класса "MyClass"
# 2. Объект у которого исчезли ссылки остается в памяти
# 3. Объкет у которого исчезли все ссылки стирается сборщиком мусора, либо в ручную
a = nil; b = nil # теперь на объект класса "MyClass" не указывают накакие переменные, тоесть он больше недостпен программисту, но все еще занимает память. В языках типа Си и Си++ такой объект так и останется в памяти, но в большинстве современных языков есть такое понятие как "сборщик мусора (garbage collector)", который отслеживает объекты, на которые больше нет никаких указателей и сам удаляет эти объекты, освобождая память
# Но сборщик мусора не обязательно удаляет все объекты без ссылок, он работает по некоторым алгоритмам и например может подолжать какоето время, пока этих объектов не накопится какоето количество, а может и вообще не замечать такие объекты, если в системе много свободной оперативной памяти. Тогда можно вызвать сборщик вручную, например в Руби это:
GC.start



puts '                                          Разное. Определения'

# heap(куча) memory - название оперативной памяти в программировании

# Объект - это определенная часть(участок) занятой оперативной памяти, которая "принадлежит" какому-то фрагмету кода, существующий во время работы программы
# Переменная не “содержит” сам объект, это просто ссылка на область памяти, где на самом деле этот объект хранится. Может быть любое количество переменных, указывающих на один и тот же объект.

# Массив — это структура данных, в которой набор различных данных непрерывно хранится в памяти. К этому набору обычно обращаются по числовому индексу, и он обеспечивает практически мгновенный доступ ко всем данным, хранящимся в массиве, в отличие от других структур, таких как двоичные деревья поиска или связанные списки, где компьютер должен обойти эти структуры, чтобы найти элемент, к которому осуществляется доступ

# Легаси код - код унаследованный(чужой) от предыдущих разработчиков

# рефакторинг кода — это процесс реструктуризации существующего компьютерного кода — изменение факторинга — без изменения его внешнего поведения. Рефакторинг предназначен для улучшения дизайна, структуры и/или реализации программного обеспечения (его нефункциональных атрибутов) при сохранении его функциональности(улучшение кода, чтоб он выглядел лучше и понятнее для разработчика)

# Валидация(validation) - обозначает проверку параметров на их соответсвие ожидаемому. Например если отправлена форма с незаполненными полями

# scraping - область програмирования для парсинга информации

# Инициализация (initialization, инициирование) — создание, активация, подготовка к работе, определение параметров

# application - (приложение)

# папка/директория/folder/каталог - это все одно и тоже

# API (application programming interface) - програмный интерфейс(а нажатие кнопочек это графический), который описывает то как с программой стоит взаимодействовать, те предоставляет способы/правила взаимодействия с программой(если мы пошлем такой-то запрос на такой-то URL, то сервер вернет нам такойто ответ). Те у каждого возможного действия есть то, что ожидается на вход и есть то, что ожидается на выходе.

# Парсер — это инструмент (чаще всего библиотека) для чтения данных из текста и представления их в удобной для работы с ними форме. Обычно их в каждом языке даже несколько.
















#
