puts '                                          HTTP и виды запросов'

# HTTP - гипертекстовый транспортный протокол, который находится на самом верхнем уровне(уровне приложений) сетевой модели OSI/ISO или TCP/IP. Именно при помощи HTTP общаются большинство приложений в интернете

# HTTP - набор байтов (текст) построенный в соответсвии с правилами этого протокола

# Первоначальная идея HTTP это способ обмена гипертекстовыми документами формата HTML, но сейчас при помощи него можно передавать практически любые данные(текстовые, фаиловые, html, xml, json)

# Любой запрос в интернете - это по сути серия запросов/ответов клиента и сервера, который содержит заголовки (header), тело (body) и всякую служебную информацию.

# HTTP зпрос к серверу состоит из 3х частей:
# 1. Стартовая линия  - содержит тип запроса и адрес сервера к которому обращаемся
# 2. Заголовки        - содржат служебную информацию: тип ОС, браузер итд
# 3. Тело запроса     - содержит информацию

# HTTP ответ от сервера состоит из этих же 3х частей:
# 1. Стартовая линия (строка статуса) - содержит статус код ответа, позволяет клиенту понять что произошло
# 2. Заголовки                        - содржат служебную информацию: тип ОС, браузер итд
# 3. Тело запроса                     - содержит информацию



puts '                                            Методы запросов'

# Методы GET, POST итд - это условное деление (конвенция), о которой просто договорились. Ничего не мешает создавать ресурс, например через GET

# методами GET и POST запросы можно отправлять с помощью формы напрямую: <form aсtion="GET".../<form ation="POST"...
# PUT, PATCH, DELETE отправляются через POST запросы, но с добавлением скрытой переменной(поля).


# 1. GET запрос(request) - это запрос от браузера серверу на получение данных, браузер хочет получить какую-то страницу(ресурс). Так же он содержит инфу о кодировках и языках поддерживаемых браузером. На этот запрос от сервера приходит ответ в виде данных запрашиваемой страницы/картинки/ресурса (html/css/...) или статус кодошибки
# Все возможные параметры для ответа на все возможные гет-запросы обычно уже заранее заданны и никакие данные от пользователя не требуются.
# GET тоже отправляет данные, но только данные пакета запроса(1 килобайт или типа того)
# Можно дополнительно передать данные(оч небольшие), эти данные будут видны в строке запрса(после знака "?"), например:
#     /cart?product_1=4,product_2=7,product_3=4,
# в адресе запроса после ? будут видны параметры, которые разделяются знаком &
#     www.yandex.ru/search/?text=запорожская+аэс&lr=37129&search_source=chromentp_desktop&src=suggest_Pers
# Это результат того что форма отправляет запрос методом GET <form aсtion="GET"...


# 2. POST запрос(request) - это запрос от браузера серверу на отправку данных на сервер, используется для передчи браузером данных на сервер (например ввод пароля, отправка сообщения на форум, залив картинки или видео). Так же содержит служебную информацию
# Отправляет данные на конкретный URL


# 3. PUT - метод запроса на обновление ресурса целиком


# 4. PATCH - метод запроса на обновление фрагмента ресурса(частичное обновление ресурса)


# 5. DELETE - метод запроса на удаление ресурса



puts '                                        HTTP GET-запрос и ответ'

# Пример GET-запроса(построчно):

# 1. GET /index.html HTTP/1.1  - начальная строка
# 2. Host: www.example.com     - один из заголовков, которых может быть много, тут доменное имя сайта на который мы отправляем запрос


# Пример ответа сервера(построчно) на запрос выше:

# 1. HTTP/1.1 200 OK                                - начальная строка
# 2. Date: Mon, 23 May 2005 22:38:34 GMT            - заголовки ответа
#    Content-Tipe: text/html; charset=UTF-8         - тип данных, которые получаем
#    Content-Encoding: UTF-8
#    Content-Length: 138
#    Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
#    Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)  - какой сервер отдал данные(ответ)
#    ETag: "3f8of-1b6-3e1cb03b"
#    Accept-Ranges: bytes
#    Connection: close
# 3. <html>                                         - тело ответа(тут это html-документ)
#    <head>
#       <title>Главная страница</title>
#    </head>
#    <body>
#       Какойто контент
#    </body>
#    </html>



puts '                                       HTTP POST-запрос и ответ'

# Пример POST-запроса(построчно):
# 1. POST /blog/ HTTP/1.1    -  стартовая строка, состоит из 3х частей(POST - метод, /blog/ - юрл, HTTP/1.1 - версия http)
# 2. Host: htmlacademy.ru
#    Contett-Tipe: application/x-www-form-urlencoded; charset=utf-8    - тип данных которые отправляем
#    Content-Length: 26      -  заголовки(headers), есть обязательные и необязательные, можно добавить и свои кастомные. В заголовках указывается информация о хосте, браузере, типе устройства с которого отправлен запрос, о типе контента, авторизационные заголовки с токенами. Так же с помощью заголовков обеспечивают безопасность взаимодействия различных источников сети.
# 3. {
#     login=user
#     password=qwerty
#   }                        - тело сообщения(body), в нем клиент отправляет серверу какието данные, форматы могут быть разные json/xml итд

# Пример ответа сервера(построчно) на запрос выше:
# 1. HTTP/1.1 200 OK         - строка статуса. Помимо версии http она возвращает статус код(200 OK), который определяет успешно был выполнен запрос или нет
# 2. Contett-Tipe: application/json   - хэдеры ответа
#    Connection: Closed
# 3. {
#     message: 'success login',
#     user: {id:'1', username ... }
#   }                        - тело сообщения(body), в котором сервер возвращает клиенту какието данные(тут json)

# Статус код(например 200 OK) - сообщает о том как был обработан запрос. Существует 5 групп статус кодов:
# 1xx - Informational(информационные). Например 100, 101 итд. Конфигурационные, чтобы понять, что "общение сложилось" ВТФ ???
# 2xx - Success(успешно).              Значит что запрос выполнен успешно, например 200.
# 3xx - Redirection(перенаправление).  Например мы успешно залогинелись и сервер нас перенаправляет на другую страницу(редиректы)
# 4xx - Client Error(ошибка клиента).  Например переданы неправильные данные(400) или страница не найдена(404) (запрашиваемая страница не существует)
# 5xx - Server Error(ошибка сервера).  Чтото пошло не так на сервере и он не смог правильно обработать запрос
# Статус коды это про семантику, тоесть мы можем послать и другой, но договорились как выше


# Идемпотентность запросов - если многократная отправка запроса приводит к одному и тому же эффекту. Например мы обновляем ресурс при помощи PUT запроса с одними и теми же данными, то сервер каждый раз должен его исполнить одинаково
# Корректно реализованные методы GET, PUT, DELETE - идемпотентны; но не метод POST, тк во многих случаях создаст новую сущность идентичную предыдущей


# Можно так же отправлять запросы вручную(тк они отправляются в текстовом виде) при помощи спец программ(пр telnet) например самый простой запрос(в консоли telnet ya.ru 80) - GET /HTTP/ 1.0  и получим ответ например код страницы

# Так же всю инфу запросов с заголовками и прочим можно посмотреть в браузерах в консоли разработчика: Network и/или Console



puts '                                            Сервер. Состояния'

# SERVER(от слова служить) - сервер только обслуживает и возвращает на наш запрос, а сам никому ничего не отправляет


# Сервер не видит разницы между различными пользователями, разница оценивается на уровне приложения, тк на сервере может быть много приложений и он возвращает на запрос то что возвращает приложение. Соотв state(состояние) поддерживается приложением а не сервером.

# https://stackoverflow.com/questions/13200152/why-is-it-said-that-http-is-a-stateless-protocol

# stateless (без состояния) (сервер не присваивает никакого специального значения и не распознает запрос по соединению) — это протокол передачи данных, который относит каждый запрос к независимой транзакции, которая не связана с предыдущим запросом, то есть общение с сервером состоит из независимых пар запрос-ответ. При каждом следующем запросе клиент и сервер общаются как впервые. Соответсвенно, чтобы идентифицировать себя, клиент должен каждый раз отправлять всю необходимую информацию для этого

# HTTP - это протокол без состояния, т.к. сервер не прицепляет никакого специального значения.
# Например был раньше протокол IRC это протокол с состоянием, тк он всегда поддерживает соединение, а ни как HTTP в котором соединение есть только при запросах и ответах



puts '                                       Проги для просмотра запросов'

# Fiddler - прога для просмотра запросов(бесплатная). Устанавливается как прокси сервер, позволяет видеть все подключения и данные запросов.(https://vimeo.com/102869014 урок18)
# Аналог на маке - charles proxy

# Там можно посмотреть тело пост запросов(данные формы), там есть левые символы которые можно преобразовать в более читабельный вид при помощи - url unescape online (search query)

# Поэтому данные HTTP и небезопасны, тк условный админ вайфай сети офисной или просто сети локальной на работе таким же фидлером может считать инфу с паролей. Соотв по этому и стоит пользоваться HTTPS на котором запросы шифруются, но правда куда мы заходим все равно будет видно


# https://portswigger.net/burp/communitydownload
# Burp Suite Community - я бы вот посоветовал использовать инструмент поновее, оно изначально делалось для security-рисёрчеров, немного посложнее, чем fiddler, но не супер сложно



puts '                                        Схема работы HTTP протокола'

#  https://ru.wikipedia.org/wiki/Сетевая_модель_OSI
# http://lib.ru/WEBMASTER/rfc2068/ - документация для http можно изучить как работает http протокол


# Когда браузер узал от DNS-сервера IP-адрес и отправил по нему HTTP-запрос, то на сервере происходит:
# У операционной сисчтемы сервера есть портык которым нужно подключаться, номер порта добавляется к IP-адресу в запросе, например 9.17.74.98:777, так же можно дописать и после текстового адреса. Веб по протоколу HTTP по умолчанию использует порт 80, потому его прописывать необязательно.
# На компьютере-сервере должен работать процесс, который называется веб-сервер, если он работает и слушает 80й порт, то запрос поступит в это приложение/веб сервер. (это обычно Apache, Nginx и другие)
# Чтобы веб сервер что-то делал, то внутри него или рядом должно работать приложение, например Ruby on Rails приложение, которое содержит в себе какую-то логику, оно получает запрос, обрабатывает, обращается в БД, на другие сервера, если нужно и возвращает обратно через веб сервер по 80му порту клиенту/браузеру данные в виде ответа по HTTP протоколу и уже его обрабатывает браузер и показывает веб страницу, картинку итд.


#                                Что происходит, когда вы вводите URL-адрес в браузере :

#      1. Разрешить домен(доменное имя например stackoverflow.com или ya.ru или localhost), если это не IP (запрос DNS) Браузер превращает доменное имя в IP-адрес(пр 	85.249.20.109  (IPv4)) и к нему подключается через порт

#      2. Откроет порт 80 по умолчанию, если не задан SSL и не переопределено двоеточием (http://host:port/).
# 127.0.0.1:80 это тоже самое что и 127.0.0.1 тоже самое что и localhost или localhost:80
# SSL - это подключение через защищенный канал например https://ya.ru

# Порты по умолчанию:
# 80 - http  например http://ya.ru
# 443 - https  например https://ya.ru
# Порт - это абстракция операционной системы или протокола(на самом деле никаких портов нет)
# 85.249.20.109:80  - можно добавить порт в конец IP-адреса

#      3. Отправляется запрос  для http://host/uri/here?other=stuff&too
# Пример запроса: использует и должен заканчиваться двумя символами возврата каретки и перевода строки (CrLf)
#   GET /uri/here?other=stuff&too HTTP/1.1
#   Host: host
#   Other: Headers, too.  Such as cookies
#   Header: Value

#      4. Получает ответ
# Пример ответа:
#   HTTP/1.1 200 OK
#   Other: Headers, too.  Such as cookies
#   Header: Value
#   <html>Actual HTTP payload is here, could be HTML data, downloaded file data, etc.

#     5. Соединение закрывается



# 1. Сначала компьютер ищет целевой хост. Если он существует в локальном кэше DNS, он использует эту информацию. В противном случае DNS-запрос выполняется до тех пор, пока не будет найден IP-адрес.
# 2. Затем ваш браузер открывает TCP-соединение с целевым хостом и отправляет запрос в соответствии с HTTP 1.1 (или может использовать HTTP 1.0, но обычные браузеры больше этого не делают).
# 3. Сервер ищет нужный ресурс (если он существует) и отвечает по протоколу HTTP, отправляет данные клиенту (=вашему браузеру)
# 4. Затем браузер использует парсер HTML для воссоздания структуры документа, которая позже будет представлена ​​вам на экране. Если он находит ссылки на внешние ресурсы, такие как изображения, файлы css, файлы javascript, они доставляются так же, как и сам HTML-документ.



# Упрощенный набросок, предполагающий простейший из возможных HTTP-запросов (без HTTPS, без HTTP2, без дополнений), простейший из возможных DNS, без прокси-серверов, IPv4 с одним стеком, только один HTTP-запрос, простой HTTP-сервер на другой конец, и никаких проблем на любом этапе. Почти нереалистичный сценарий, в реальном использовании почти всегда сложнее:

# 1.  браузер проверяет кеш(это хранилище браузера на жеском диске, чтоб быстрее загружать страницы); если запрошенный объект находится в кеше и является свежим, переходим к  пункту 9
# 2.  браузер запрашивает у операционной системы(тк именно она превращает запрос в IP-адрес для браузера) IP-адрес сервера[(пункт 1 в самом вехнем списке)]
# 3.  ОС выполняет поиск DNS и отвечает на IP-адрес в браузере.
# 4.  браузер открывает TCP-соединение с сервером (этот шаг намного сложнее с HTTPS) [(пункт 2 в первом списке)]
# 5.  браузер отправляет HTTP-запрос через TCP-соединение[(пункт 3 в первом списке)]
# 6.  браузер получает HTTP-ответ и может закрыть TCP-соединение или повторно использовать его для другого запроса. [(пункт 4-5 в первом списке)]
# 7.  браузер проверяет, является ли ответ перенаправлением или условным ответом (коды состояния результата 3xx), запросом авторизации (401), ошибкой (4xx и 5xx) и т. д.; они обрабатываются иначе, чем обычные ответы (2xx)
# Может быть такой запрос который перенаправляет браузер, тогда браузер не завершает соединение а переходит туда куда перенаправили(можно сделать многократное перенаправление или зациклить, но в браузерах есть от этого защита)
# 8.  если ответ можно содержать в кеше, чтобы не перезагружать снова(некоторые документы можно содержать в кеше например картинки), ответ сохраняется в кеше. Но есть картинки с опцией перезагрузки(об этом сообщается в ответе сервера) например капча
# 9.  браузер декодирует ответ (например, если он заархивирован). Тк большинство серверов сейчас присылают ответ не в текстовом а в сжатом виде
# 10. браузер определяет, что делать с ответом (например, это HTML-страница, это изображение, это звуковой клип)
# 11. браузер отображает ответ или предлагает диалог загрузки для нераспознанных типов

# Кроме того, параллельно с этим происходит много других вещей (обработка введенного адреса, спекулятивная предварительная выборка, добавление страницы в историю браузера, отображение прогресса для пользователя, уведомление плагинов и расширений, рендеринг страницы во время ее загрузки, конвейеризация, отслеживание соединения для keep-alive, управление файлами cookie, проверка на наличие вредоносного контента и т. д.) — и вся операция становится на порядок сложнее с HTTPS (сертификаты, шифры и закрепление).



puts '                                   О разделении бэкенд и фронтэнд'

# На сервере происходит обработка запроса по определенному URL по протоколу HTTP. Сервер возвращает браузеру фаилы html, js, css  и другие, которые браузер использует, чтобы отрисовать страницу.

# Но эта страница так же может сама при помощи браузера обращаться к серверу, чтобы постоянно не перезагружать всю страницу, например для того чтобы подгрузить новые посты - это помимо визуала тоже фронтэнд. Тоесть логика происходящая на веб странице клиента.



puts '                                           Структура URL'

# https://ru.wikipedia.org/wiki/URL - статья википедии про URL, потом прочитать

# https://ru.wikipedia.org/wiki/URL#%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_URL
# https: - зашифрованный протокол http
# // - хз зачем (создатель http считает их лишними)
# ru.wikipedia.org - название хоста, которое DNS-сервером (чтобы выдать браузеру IP-адрес) разбиррается с конца:
#     org - доменная зона
#     wikipedia - домен
#     ru - поддомен, разбирается уже на сервере приложения(тут Википедии)
# /wiki/URL - адрес (тут URL часть адреса так как статья про URL)
# #%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_URL - якорь, после # закодированны точки и русские символы


# URL с параметрами:
# https://www.youtu.be/watch?v=PslExWYTD8U&t=897
# www - тоже поддомен
# ?v=PslExWYTD8U&t=897  - параметры идкт после вопроса и разделяются &, тут это айди видео(v=PslExWYTD8U) и время на котором его открыть(t=897)



puts '                                          API приоложения'

# API (application programming interface) - програмный интерфейс (а нажатие кнопочек это графический), который описывает/предоставляет способы/правила взаимодействия с программой (если мы пошлем такой-то запрос на такой-то URL, то сервер вернет нам такой-то ответ). Те у каждого возможного действия есть то что ожидается на вход и есть то что ожидается на выходе.

# API например есть у многих приложений, соцсетей, месеннджеров итд - позволяет без ручного ввода через браузер и сложного кастомного парсинга, програмным способом запрашивать данные со страниц приложения (везде это все может быть устроено по разному, соответственно нужно почитать документацию API с которым мы хотим взаимодействовать)

# Основная фича в том что мы заходим в приложение не через браузер руками, а через программу, соотв эту программу нужно идентифицировать, для этого в API соотв приложения часто нужно сгенерировать специальный токен для входа через программу

# Например в Twitter API функционал находится на странице твитер-девелопмент, на ней есть все что необходимо для разработчика, нужно зарегаться, создать новый проект, и в нем создать наше приложение, через которое чтото будем запрашивать из твитера, будем заходить в твитер через это приложение
















#
