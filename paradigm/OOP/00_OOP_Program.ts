//                                                  ООП

// https://habr.com/ru/articles/87205/   -   определения наследования, инкапсуляции, абстракции, полиморфизма

// ООП (объектно-ориентированное программирование) - парадигма программирования, основанная на концепции «объектов», которые могут содержать данные в виде полей, часто называемых атрибутами; и код в виде процедур, часто называемых методами.
// Помогает дробить программу на отдельные части(классы), которые более удобны и понятны для разработчика
// Особенностью объектов является то, что процедуры объекта могут получать доступ и часто изменять поля данных объекта, с которыми они связаны. Таким образом, объектно-ориентированные компьютерные программы состоят из объектов, которые взаимодействуют друг с другом

// Методы, Классы, Модули и другие элементы ООП - это абстракция, которая существует только для программиста, чтоб облегчить ему жизнь.

// Метод в ООП — это функция, принадлежащая какому-то классу или объекту. Методы классифицируются по применимости к объектам: статические и простые/нестатические; по возможности использования: например в Руби это public, private, protected. Метод может работать с данными, содержащимися в классе (помня, что объект является экземпляром класса - класс является определением, объект является экземпляром этих данных)

// Основная задача ООП — избавиться от дублирования кода, упростить систему, сделать ее более поддерживаемой, и сократить финансовые расходы на разработку.

// Ключ к эффективному созданию объектно-ориентированных программ заключается в том, чтобы не усложнять архитектуру, а упрощать

// ООП построена на 3х концепциях: инкапсуляция, наследование, полиморфизм



//                                              Классы и объекты

// Класс - в ООП это набор свойств/характеристик, которыми можно охарактеризовать каждый его отдельный объект. Класс по простому это шаблон/чертеж/иструкция для создания объекта. Например есть человек и любого человека можно охарактеризовать свойствами: имя и возраст
// Классы содержат данные, имеют методы, которые взаимодействуют с этими данными и используются для того, чтобы создавать объекты на основе этих классов
// Методы и функции, а также поля и переменные это одно и тоже. В классах функции называются методами, а переменные называются полями, но работают они одинаково.
// Класс - это определенная зона ответсвенности как скоуп и в идеале каждый класс должен делать чтото одно, один тип действий.


// Объект/экземпляр/instance класса - это конкретный представитель класса, для него каждое свойство класса имеет конкретное значение, например Вася, которому 27 лет
// Отдельные объекты занимают отдельные ячейки памяти и никак не связаны, кроме принадлежности к клессу.
// Характеристики объекта называются свойствами, а действия, которые может совершать объект, называются методами, например Вася может ходить, говорить итд


// Когда мы создаем объекты(экземпляры класса/class instance), принадлежащие классу(нашему типу данных), то они будут обладать всеми характеристиками и параметрами, которые были заданы классом.
// Впоследсвии удобно добавлять характеристики уже существующим объектам, просто добавляя их в класс, а не в каждый объект отдельно.


// Класс Прямоугольник
class Rectangle {
  // У него есть 2 свойства: ширина и высота
  width;
  height;
  // У любого класса есть конструктор - это специальный метод, содержащий набор инструкций, которые вызываются при создании нового объекта. Обычно в конструкторе свойствам объекта присваиваются какие-то начальные значения
  constructor(w, h) {
    this.width = w;
    this.height = h;
  }
  // метод экземпляра, манипулирующий свойствами, тут считающий площадь, перемножая значения свойств
  calcArea() {
    return this.width * this.height;
    // this - возвращает объект от которого быдет вызван данный метод, соотв от него возьмем и свойства
  }
  // Каждый класс может включать в себя любое колличество свойств и методов, но хорошей практикой считается делать классы под конкретные задачи, только с теми свойствами и методами, которые для них необходимы
}
// Создаем новый объект и передаем аргументами значения для его свойств.
const rect = new Rectangle(w: 5, h: 10);
// Можем создать любое колличество объектов:
const rect2 = new Rectangle(w: 3, h: 9);
// От созданных объектов мы можем вызвать метод экземпляора
rect.calcArea()  //=> 50
rect2.calcArea() //=> 27



//                                            Инкапсуляция и сокрытие

// https://vk.com/@physics_math-skryvaite-sekrety-inkapsuliruite-detali-realizacii  - статья о принципах инкапсуляции

// Инкапсуляция - сам класс является своего рода капсулой, которая содержит в себе свойства и методы для работы с этими свойствами, тоесть инкапсуляция позволяет все это объединить.

// Инкапсуляция (encapsulation) в программировании — это принцип, согласно которому внутреннее устройство сущностей нужно объединять в специальной «оболочке» и скрывать от вмешательств извне. Доступ к объектам возможен через специальные открытые методы, а напрямую обратиться к их содержимому нельзя.

// Также инкапсуляцию описывают как принцип разделения логики и поведения. Логика — то, как что-то устроено внутри, а поведение — то, как оно взаимодействует с другими сущностями. Разделение этих двух понятий упрощает взаимодействие объектов в коде.

// Сокрытие - создание скрытой части класса, например скрытые свойства и методы, которые нельзя вызвать вне тела класса. Для того чтобы делать методы или свойства публичными или приватными во многих языках существуют модификаторы доступа public и private

class Rectangle {
  // Сделаем свойства приватными, тоесть не сможем обратиться к ним извне класса. Нижнее почеркивание в имени свойства указывает на то что оно приватное - это некое соглашение в JS, TS и некоторых других языках.
  // Чаще всего все свойства делают приватными.
  private _width;
  private _height;

  constructor(w, h) {
    this._width = w;
    this._height = h;
  }

  // Для того чтобы получить доступ к приватным свойствам, тоесть получать их или изменять создаются специальные методы - геттеры и сеттеры. Так же помимо возврата и изменения можно прописать в них доп логику
  get width() {
    return this._width;
  }
  // Если явно не указывать модификатор доступа для свойств или методов, то по умолчанию он будет public, но хорошей практикой бкдет указывать его явно:
  public set width(value) {
    if (value <= 0) this._width = 1;
    else this._width = value;
  }

  // Для свойства height сделали только геттер, тоесть изменять его мы не сможем
  get width() {
    return this._height;
  }
}

// Например класс БД, у которого свойства это URL-адрес и пользователь с паролем который подключается к БД, значения этих свойств мы присваиваем от параметров переданных от объекта и создаем для них геттеры. При этом так же будет список таблиц, которые содержит в себе эта БД, изначально будет пустым массивом, созданным внутри конструктора
class Database {
  private _url;
  private _username;
  private _password;
  private _tables;

  constructor(url, username, password) {
    this._url = url;
    this._username = username;
    this._password = password;
    this._tables = [];
  }

  // Чтобы добавлять таблицы в массив this._tables создадим отдельный метод, при этом менять этот массив напрямую мы не можем, а только при помощи данного метода
  public createNewTable(table) {
    this._tables.push(table);
  }
  // Чтобы удалить таблицы из массива тоже можно создать отдельный метод
  public clearTables() {
    this._tables = [];
  }

  get url() {
    return this._url;
  }
  get username() {
    return this._username;
  }
  get password() {
    return this._password;
  }
}



//                                                  Наследование

// Наследование - способ взаимодействия между классами, позволяет переиспользовать код, тк класс получает свойства и методы от родительского класса

// С помощью наследования можно создавать целую иерархию классов, где каждый класс наследник перенимает свойства и методы родительского класса и может дополнительно обладать и своими собственными свойствами

// В большинстве языков программирования нет множественного наследования, тоесть класс не может наследовать сразу от нескольких других классов. Но в тех языках, где множественное наследование есть, например C++, класс наследник примет все свойства и методы от всех классов у которых он наследует.

// Создадим класс человека со свойствами, геттерами и сеттерами
class Person {
  private _name;
  private _age;

  constructor(name, age) {
    this._name = name;
    this._age = age;
  }

  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }

  get age() {
    return this._age;
  }
  set age(value) {
    this._age = value;
  }
}

// Создадим класс работника, у которого должны быть теже свойства, что и у класса человека, но еще и свои собственные свойства. Для того чтобы не писать теже самые свойства используем наследование, те расширим класс работника от класса человека
class Employee0 extends Person {
  // Теперь класс Employee наследует свойства методы и конструктор у класса Person
}
// Соответсвенно мы можем создать объект с заданием значений унаследованных свойств
const employee0 = new Employee0(name: 'Vasya', age: 15);

// Добавим новые свойства в класс наследник
class Employee extends Person {
  private _inn;
  private _pasport_number;

  // Переопределяем конструктор, чтобы добавить значения новых свойств
  constructor(name, age, inn, pasport_number) {
    super(name, age); // значения старых свойств отправляем в родительский конструктор, который вызываем функцией super
    this._inn = inn;  // и только потом задаем значения новых свойств
    this._pasport_number = pasport_number;
  }
}
// Теперь можно создать объект с заданием значений и унаследованных и своих свойств
const employee = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456);

// Создадим класс разработчика, который будет наследовать уже от класса работника
class Developer extends Employee {
  private _level;

  constructor(name, age, inn, pasport_number, level) {
    super(name, age, inn, pasport_number); // значения старых свойств отправляются в родительские конструкторы
    this._level = level;
  }
}
// Экземпляр с заданием значений и унаследованных и своих свойств
const developer = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456, level: 'MIDDLE');



//                                               Полиморфизм

// Полиморфизм - концепция ООП, которая позволяет одному и тому же фрагменту кода работать с разными типами данных одинаково. Возможно самый важный принцип ООП и на нем основаны почти все паттерны проектирования

// Выделяют 2 типа полиморфизма: параметрический полиморфизм (истинный) и ad-hoc полиморфизм (мнимый)


// 1. ad-hoc полиморфизм (мнимый). Например в классе Calculator есть 2 метода, которые называются одинаково, принимают одинаковые параметры, но они разных типов, 1й метод принимает числовой тип, а 2й строковый. В итоге при вызове как бы одного и того же метода в зависимости от типов передаваемых параметров, произведем или сложение чисел или конкатинацию строк. Происходит засчет перегрузки методов.
class Calculator {
  add(a :number, b :number): number {
    return a + b;
  }
  add(a :string, b :string): string {
    return a + b;
  }
}


// 2. Параметрический полиморфизм (истинный):

// Материнский класс имеет метод greeting
class Person {
  private _name;
  constructor(name, age) {
    this._name = name;
  }
  public greeting() {
    console.log(`Привет я человек, меня зовут ${this._name}`);
  }
}

// Класс наследник наследует метод greeting, но переопределим его, чтобы он выводил другое сообщение
class Employee extends Person {
  private _pasport_number;
  constructor(name, pasport_number) {
    super(name);
    this._pasport_number = pasport_number;
  }
  public greeting() {
    console.log(`Привет я работник, меня зовут ${this._name}, мой номер паспорта ${this._pasport_number}`);
  }
}

// Объекты и материнского класса и класса наследника могут использовать как бы один и тот же метод
const person = new Person(name: 'Vasya');
const employee = new Employee(name: 'Petya', pasport_number: 158786867);
person.greeting()   //=> "Привет я человек, меня зовут Vasya"
employee.greeting() //=> "Привет я работник, меня зовут Petya, мой номер паспорта 158786867"

// Можем реализовать функцию
function massGreeting(persons: Person[]) {
  for (let i = 0; i < persons.length; i++) {
    const person = persons[i];
    person.greeting() // одинаковым способом вызываем функцию с разной логикой для разных типов объектов это и есть полиморфизм
  }
}
const personList: Person[] = [person, employee]; // указываем что массив типа Person без явного указания типов отдельных классов
massGreeting(personList)



//                                            Агрегация и композиция

// Агрегация и композиция - как и наследование это способы взаимодействия между классами

// Композиция - объект класса использует внутри себя объекты другого класса, все эти объекты не существуют отдельно от объекта, который их использует и создаются внутри него

// Композиция реализует отношение has-a, в отличие от отношения is-a подтипирования. Композиция объекта заключается в объединении объектов внутри составных объектов и в то же время обеспечении инкапсуляции каждого объекта с помощью их четко определенного интерфейса без видимости их внутренних элементов.

// Агрегация - объект класса использует внутри себя объекты другого класса, некоторые из этих объектов могут существовать отдельно от объекта, который их использует и создаются вне него

class Engine { // Класс двигатель
  drive() {
    console.log(`Двигатель работает`);
  }
}

class Wheel { // Класс колесо
  drive() {
    console.log(`Колесо крутится`);
  }
}

class Biker { } // Класс байкер

class Moto { // Класс мотоцикл
  engine: Engine; // Свойсво типа Двигатель
  wheels: Wheel[]; // Массив типа Колесо
  biker: Biker;

  constructor(biker) {
    // Агрегация - объект передается в класс извне
    this.biker = biker;
    // Композиция - создаем объекты внутри класса
    this.engine = new Engine();
    this.wheels.push(new Wheel());
    this.wheels.push(new Wheel());
  }
  // Делегирование. Создадим метод drive у мотоцикла и внутри него происходит делегирование - те вызывается такой же метод у колес и двигателя
  drive() {
    this.engine.drive();
    for (let i = 0; i < this.wheels.length; i++) { this.wheels[i].drive(); }
  }
}

// Создадим объект
const moto = new Moto(biker: new Biker());

// Теперь если удалим объет мотоцикла, то двигатель и колеса так же удалятся, а байкер нет



//                                    Абстрактные классы и интерфейсы

// Интерфейс - в нем описываются методы с параметрами их типами и типами возврата этих методов, но при этом нет реализации этих методов. Интерфейс это как оглавление в книге, он описывает что нужно сделать, но не описывает как это нужно сделать. От интерфейса нельзя создать объект. Класс имплементирующий интерфейс должен реализовывать все методы, что есть в этом интерфейсе. Имплементировать один интерфейс могут разные классы, при этом реализация методов интерфейса может отличаться у каждого класса.
// Позволяют писать более гибкий код, с более гибким полиморфизмом и в первую очередь систему нужно проектировать на уровне интерфейсов
interface Client {
  connect(url:string):void;
  read():string;
  write(data:string):void;
}

// Абстрактный класс - похож на интерфейс, в нем можно объявлять абстрактные методы, которые будут аналогами методов интерфейса, те без реализации, но при этом можно создавать и обычные методы с какой-то реализацией. Класс который унаследует от абстрактного, унаследует обычные методы и должен будет реализовать абстрактные методы. Абстрактные классы используются существенно реже интерфейсов
abstract class Client {
  connect(url:string):void {
    // какаято логика
  }
  abstract read():string;
  abstract write(data:string):void;
}


// Пример использования интерфейсов:
interface Reader { // интерфейс 1
  read(url);
}

interface Writer { // интерфейс 2
  write(data);
}

class FileClient implements Reader, Writer { // класс может имплементировать несколько интерфейсов, тоесть реализовать методы из каждого из этих интерфейсов
  read(url) {
    // какая-то логика
  }
  write(data) {
    // какая-то логика
  }
}


// Пример использования интерфейсов 2 (? Тут репозиторий аналог контроллера, а Юзер и Кар модели ?):
// Создадим класс, с объектами которого бует работать класс, имплементирующий интерфейс ниже
class User {
  username: string;
  age: number;
}
// Можем создать другой класс с объектами которого бует работать другой класс имплементирующий интерфейс
class Car {
  carname: string;
}
// Создадим интерфейс Репозиторий с 4мя CRUD методами. Тк в классе, в который имплементируем интерфейс методы ожидают аргументы, то добавим в интерфейс обобщение/дженерик для типов принимаемых и возвращаемых данных - в данном случае тип T это чтото общее, какойто тип данных приходящий извне
interface Repository<T> {
  create: (obj: T) => T;
  get: () => T;
  delete: (obj: T) => T;
  update: (obj: T) => T;
}
// Создадим класс Юзер-Репозиторий, который имплементирует интерфейс репозитория и реализует его методы, так же добавим в таких же скобках тип данных, который будет использоваться везде где в интерфейсе есть тип T
class UserRepo implements Repository<User> {
  create(user: User): User {
    return database.query(INSERT ...);
  }
  get(): User {
    return undefined;
  }
  delete(user: User): User {
    return undefined;
  }
  update(user: User): User {
    return undefined;
  }
}
// Создадим другой класс Кар-Репозиторий, который тоже имплементирует интерфейс репозитория и реализует его методы, но уже с другим типом данных
class CarRepo implements Repository<Car> {
  create(user: Car): Car {
    return database.query(INSERT ...);
  }
  get(): Car {
    return undefined;
  }
  delete(user: Car): Car {
    return undefined;
  }
  update(user: Car): Car {
    return undefined;
  }
}

// Тоесть еще на этапе проектирования создаем интерфейс, в котором определяем какие должны быть методы, а потом подстраиваясь под этот интерфейс реализуем некоторые классы



//                               Паттерн Dependency injection (Внедрение зависимостей)

// Dependency injection (Внедрение зависимостей) - паттерн. Используется множеством фрэймворков например: Спринг, Ангуляр, НекстЖС
// Приложение разделено на слои:
// 1й слой отвечает за логику по работе с БД(получить, записать, обновить, удалить данные). У репозиторного слоя может быть несколько реализаций, наример для работы с МонгоДБ и для работы с ПостгрэSQL, тоесть в зависимости от неких условий мы работаем с одной или другой СУБД
// 2й слой это сервисный слой тоесть какая-то бизнес логика, в котором может быть что угодно, например работа с репозиторием, тоесть с 1м слоем. Если использует внутри себя репозиторий, то можно чтобы сервисний слой вообще не знал какой из репозиториев он использует. У него есть интерфейс к которому он обращается, получает какие-то данные из репозиторного слоя и ему не важно работает он с Монго или Постресс репозиторием. На уровне сервиса мы работаем с некоторым интерфейсрм в репозитории, а имплементацию/реализацию этого репозитория Моного или Постресс мы определяем где-то снаружи, например на уровне конфигурации, при этом чтобы изменить одну имплементацию на другую нам не нужно править сервисний слой и достаточно изменить кофигурацию

// (? Тут репозиторий аналог контроллера ?)

// Интерфейс Юзер-репозитория в котором описаны CRUD методы для работы БД с пользователями
interface UserRepo {
  getUsers: () => User[];
  // create:, delete:, update: остальные методы CRUD
}
// Реализация для работы с MongoDB, которая имплементирует интерфейс UserRepo
class UserMongoDBRepo implements UserRepo {
  // Метод получает пользователей из БД MongoDB
  getUsers(): User[] {
    console.log('Используем подключение к MongoDB и получаем пользователей');
    return [{age: 15, username: 'Пользователь из MongoDB'}];
  }
}
// Реализация для работы с Postgres, которая имплементирует интерфейс UserRepo
class UserPostgresRepo implements UserRepo {
  // Метод получает пользователей из БД Postgres
  getUsers(): User[] {
    console.log('Используем подключение к Postgres и получаем пользователей');
    return [{age: 15, username: 'Пользователь из Postgres'}];
  }
}
// Класс с бизнес логикой. Может внутри себя использовать репозитори MongoDB или Postgres
class UserService {
  userRepo: UserRepo; // Указываем, что в данном классе используем юзер-репозиторий, но как тип указываем не конкретный класс(имплементацию), а сам интерфейс
  // Инициализируем это свойство через конструктор, тоесть принимаем репозиторий извне
  constructor(userRepo: UserRepo) {
    this.userRepo = userRepo;
  }
  // Внутри метода сервиса вызываем метод из репозитория, который возвращает нам список пользователей
  filterUserByAge(age: number) {
    counst users = this.userRepo.getUsers();
    // ... какая-то логика по фильтрации
    console.log(users);
  }
}
// Создадим объект UserService и передаем какой либо из репозиториев (имплементаций) в конструктор
const userService = new UserService(new UserMongoDBRepo())
userService.filterUserByAge(age: 15); //=> [{age: 15, username: 'Пользователь из MongoDB'}]
// Передадим в конструктор сервиса другую имплементацию для работы с Postgres
const userService = new UserService(new UserPostgresRepo())
userService.filterUserByAge(age: 15); //=> [{age: 15, username: 'Пользователь из Postgres'}]
// Тоесть мы извне определяем как будет работать сервис, передавая соответсвующий аргумент в конструктор, например для Монго, Постресс, потом решим хранить фаилы вообще в фаилах, для чего нам нужно просто передать соответсвующую имплементацию в конструктор сервиса



//                                                 Синглтон

// Синглтон - паттерн проектирования из банды 4х

// Для класса БД необходимо гарантировать, что будет создан лишь один объект, потому что несколько в нашем приложении быть не может, тк если кто-то создаст еще один экземпляр БД, то будет уже 2 подключения
class Database {
  url: number;
  private static instance: Database; // Добавим приватное статичное(принадлежащее классу, а не объекту) поле, тк мы его нигде не инициализировали, то изначально оно является null

  constructor() {
    if (Database.instance) { // если эта переменная не равна null, а содержит объект БД, тоесть объект БД уже существует ...
      return Database.instance; // ... то возвращаем его
    }
    // А если не существует, тогда инициализируем свойства, создаем объект БД и присваиваем его в переменную класса
    this.url = Math.random(); // проинициализируем свойство рандомным числом для примера
    Database.instance = this;
  }
}
// Создадим 2 объекта этого класса и выведем ЮРЛ каждого в консоль
const db1 = new Database();
const db2 = new Database();
// В итоге выведут ондно и тоже рандомное число и сколько объектов мы бы не создали, всегда это будет один и тот же объект
console.log(db1.url);
console.log(db2.url);













//
