puts '                                      SOLID, DRY, KISS и YAGNI'

# Принципы SOLID, DRY, KISS и YAGNI - это мощные инструменты, которые помогают писать качественный код. Это не жесткие правила, а скорее рекомендации, которые нужно применять с умом, учитывая контекст конкретного проекта

# Эти принципы часто работают вместе:
# * SOLID помогает писать DRY код, разбивая большие классы на более маленькие и переиспользуемые.
# * KISS и YAGNI помогают применять SOLID более разумно, избегая излишних абстракций.
# * DRY помогает предотвратить нарушения принципа единственной ответственности (SRP) в SOLID, поскольку избегает дублирования логики, которая могла бы быть разбита между несколькими классами.



puts '                                               SOLID'

# SOLID - обозначает пять базовых принципов объектно-ориентированного проектирования. Их цель – создание кода, который легко поддерживать, расширять и переиспользовать


# S (Single Responsibility Principle / Принцип единственной ответственности). Класс должен отвечать только за одну конкретную часть функциональности. Если класс отвечает за несколько вещей, то изменение в одной части функциональности может неожиданно повлиять на другую. Это усложняет тестирование и отладку.


# O (Open/Closed Principle / Принцип открытости/закрытости). Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Позволяет добавлять новую функциональность, не изменяя существующий код. Это снижает риск внесения ошибок в уже работающий код

# Есть класс для расчета зарплаты:
class Salary
  def calculate(employee)
    if employee.type == 'full_time'
      # Расчет для постоянного сотрудника
    elsif employee.type == 'part_time'
      # Расчет для временного сотрудника
    end
  end
end

# Если в будущем появится новый тип сотрудников, придется изменять существующий класс. Вместо этого можно создать отдельные классы для каждого типа сотрудника и использовать полиморфизм:
class Salary
  def calculate(employee)
    employee.calculate_salary
  end
end

class FullTimeEmployee
  def calculate_salary
    # Логика для постоянного сотрудника
  end
end

class PartTimeEmployee
  def calculate_salary
    # Логика для временного сотрудника
  end
end
# Теперь добавление новых типов сотрудников не требует изменения класса Salary


# L (Liskov Substitution Principle / Принцип подстановки Барбары Лисков). Объекты подклассов должны иметь возможность быть заменены на объекты суперклассов без изменения корректности программы. Обеспечивает, что полиморфизм работает как ожидается.

# Есть класс Bird и его подкласс Penguin:
class Bird
  def fly
    "Flying"
  end
end

class Penguin < Bird
  def fly
    raise "Penguins can't fly!"
  end
end
# Здесь нарушается принцип Лисков, так как пингвины не могут летать, но класс Penguin наследует метод fly, что создает ошибку

# Можно создать общий интерфейс для всех птиц и специализированные классы:
class Bird
  def move
    raise NotImplementedError
  end
end

class FlyingBird < Bird
  def move
    "Flying"
  end
end

class Penguin < Bird
  def move
    "Swimming"
  end
end


# I (Interface Segregation Principle / Принцип разделения интерфейса). Клиенты (?субклассы?) не должны зависеть от интерфейсов, которые они не используют полностью, это уменьшит связность и сделает код более гибким

# Есть интерфейс для управления работниками:
class Employee
  def work
    # Работа
  end

  def eat
    # Перерыв
  end
end
# Если есть класс Robot, который должен работать, но не делать перерыв, ему все равно придется реализовать метод eat

# Можно разделить интерфейсы:
class Worker
  def work
    raise NotImplementedError
  end
end

class Human < Worker
  def work
    # Логика работы
  end

  def eat
    # Логика перерыва
  end
end

class Robot < Worker
  def work
    # Логика работы
  end
end


# D (Dependency Inversion Principle / Принцип инверсии зависимостей). Вместо того чтобы модули высокого уровня (бизнес-логика) напрямую зависели от модулей низкого уровня (детали реализации, такие как БД или API), они должны зависеть от интерфейсов или абстрактных классов, от которых уже реализуются модули низкого уровня. Снижает связность между модулями и делает код более гибким и тестируемым

# Есть сервис, который зависит от конкретной реализации базы данных:
class UserService
  def initialize(database)
    @database = database
  end

  def save_user(user)
    @database.save(user)
  end
end

class MySQLDatabase
  def save(user)
    # Логика сохранения в MySQL
  end
end
# Здесь класс UserService зависит от конкретной базы данных MySQLDatabase

# Вместо этого мы можем использовать интерфейс базы данных. Теперь сервис может работать с любой базой данных, реализующей этот интерфейс
class SQLDatabase
  def save(user)
    raise NotImplementedError, "Subclasses must implement save method"
  end
end

class MySQLDatabase
  def save(user)
    # Логика сохранения в MySQL
  end
end

class PostgreSQLDatabase
  def save(user)
    # Логика сохранения в PostgreSQL
  end
end



puts '                                               DRY'

# DRY (Don't Repeat Yourself) - каждый фрагмент должен иметь единственное, непротиворечивое и авторитетное представление в системе

# Избегает дублирования кода. При изменении логики нужно будет изменить ее только в одном месте, а не во многих. Это упрощает поддержку и снижает риск ошибок.



puts '                                               KISS'

# KISS (Keep It Simple, Stupid / Делай проще, глупыш). Избегайте ненужной сложности, тк большинство систем лучше всего работают, если они остаются простыми, а не усложняются

# Упрощает понимание, разработку и отладку кода. Более простой код обычно более надежен.



puts '                                               YAGNI'

# YAGNI (You Ain't Gonna Need It / Вам это не понадобится). Не добавляйте функциональность, пока она вам действительно не понадобится

# Избегает разработки функциональности, которая никогда не будет использована. Это тратит время и ресурсы, а также усложняет код

# Пример: Не создавайте абстрактные классы и интерфейсы "на всякий случай".  Начните с конкретной реализации и рефакторите ее, когда это действительно необходимо.












#
