puts '                                      Теория (на примере ЖС)'

# Есть глобальная памать там обычно записывается набор созданных переменных, например переменных с функцией, тоесть набор инструкцией, некая строка которая ничего не делает, пока не будут использованы круглые скобки для ее переменной, тоесть обратимся к этому уровню памяти и на основе инструкций что-то сделаем

# В момент выова функций создается контекст вызова этой функции. У контекста есть своя локальная память, в которой хранятся свои переменные, например там хранятся параметры фукнкции, какието переменные созданные в теле функции. И в стеке вызова функции получается новый уровень поверх глобального, который существует пока выполняется эта функция, она в это время будет хранится в памяти. Когда функция закончит выполнения то и контекст вызова будет удален, локальная память очищена

# Если в теле функции вызвать еще раз функцию, то внутри конткста выхова появляется еще один контекст вызова функции, в стеке вызова появляется еще один слой, и в памяти уже есть 2 функции

# Если делать так много раз то рано или позно место в оперативной памяти компьютера закончится и выведет ошибку что стек вызова переполнен

# Чтобы стек вызова не был переполнен, необходимо создать условие выхода. В Рекурсии условие выхода называется - базовое условие. Как правило код функции рекурсии  начинается с базового условия
let count = 0;
function recurse() {
  if (count == 5) return 'done'; # базовое условие
  count += 1;
  return recurse();
}
recurse()

# Так же помимо базового условия в рекурскии может быть сценарий/правило движения функции по рекурсии
function pow(x, y) {
  if (y == 0) return 1; # базовое условие
  return x * pow(x, y-1); # правило движения функции
}
pow(5, 3)



puts '                                             Рекурсия'

# Рекурсия - функция вызывает сама себя, чтобы получить некий промежуточный результат

# Рекурсивная реализация не имеет изменяемого состояния как итеративная, но у нее есть проблема с потреблением памяти.

# Факториал 5 = 5 * 4 * 3 * 2 * 1
# Факториал 4 =     4 * 3 * 2 * 1
# Соответсвенно Факториал 5 = 5 * Факториал 4
# Факториал n = n * Факториал n-1
def factorial(n)
  puts "x = #{n}"
  if n == 1
    return n
  else
    return n * factorial(n - 1) # вызывается таже функция но с новым значением, соответвенно вернет значение этот внутренний вызов функции сюда во внешний вызов и так на каждом новом круге вовнутрь.
  end
end
p factorial(5) #=> 120
# puts:
# x = 5
# x = 4
# x = 3
# x = 2
# x = 1



puts '                                          Примеры и решения'

# 4 kyu Hash.flattened_keys
# https://www.codewars.com/kata/521a849a05dd182a09000043
def flattened_keys(obj)
  obj = obj.map do |k, v|
    if v.class == Hash || v.class == Array
      v.map { |key, val| [k.class == Symbol && key.class == Symbol ? "#{k}_#{key}".to_sym : "#{k}_#{key}", val] }
    else
      [k, v]
    end
  end.flatten

  if obj.any?{|e| e.class == Hash || e.class == Array}
    flattened_keys(obj.each_slice(2).to_a)
  else
    obj.each_slice(2).to_h
  end
end

obj = {a: 1, 'b' => 2, info: {id: 1, 'name' => 'example', more_info: {count: 1}}}
p flattened_keys(obj) #=> {:a=>1, "b"=>2, :info_id=>1, "info_name"=>"example", :info_more_info_count=>1}














#
